Answers of Lab3:

### Question 1
> What is the purpose of having an individual handler 
function for each exception/interrupt? (i.e., if all 
exceptions/interrupts were delivered to the same handler, 
what feature that exists in the current implementation could 
not be provided?)

因为对于某一些中断处理器处理时不会往栈上压入一些参数，例如"errorno"，
而有些中断不会，为了保持访栈结构的一致性，需要对不同的中断生成不同的handler。
### Question 2
> Did you have to do anything to make the user/softint program
 behave correctly? The grade script expects it to produce a 
general protection fault (trap 13), but softint's code says
int $14. Why should this produce interrupt vector 13? What 
happens if the kernel actually allows softint's int $14 
instruction to invoke the kernel's page fault handler (
which is interrupt vector 14)?

不能。因为对于第十四个中断的DPL(Descriptor Privilege Level)设置
成0。所以中断处理只能在Ring0模式下运行。操作系统约定page fault只能通过硬
件产生，不会在用户态产生。因此如果用户调用'int $14'(page fault的处理中断)
时，会产生general protection fault。

### Questions 3
> The break point test case will either generate a break point
 exception or a general protection fault depending on how you 
initialized the break point entry in the IDT (i.e., your call 
to SETGATE from trap_init). Why? How do you need to set it up 
in order to get the breakpoint exception to work as specified 
above and what incorrect setup would cause it to trigger a 
general protection fault?   

同问题2差不多，有关break point IDT表中DPL(Descriptor Privilege Level)
应该设置成Ring3：
SETGATE(idt[T_BRKPT], 1, GD_KT, brkpt_entry, 3)，
表示该中断能够被运行在高于或等于Ring3特权下的程序运行。若设置成小于3，则会触发
general protection fault。

### Question 4
> What do you think is the point of these mechanisms,
 particularly in light of what the user/softint test program does?

这些机制能够保证系统不被用户的某些中断破坏。如果用户能够利用中断管理页表，
那么会变得危险。而用户利用Break point操作，不会威胁到整个系统的安全。