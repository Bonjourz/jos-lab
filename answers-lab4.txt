Answers of Lab4
1. Compare kern/mpentry.Sside by side with boot/boot.S . Bearing in mind 
that kern/mpentry.S is compiled and linked to run above KERNBASE just 
like everything else in the kernel, what is the purpose of macro MPBOOTPHYS ? 
Why is it necessary in kern/mpentry.S but not in boot/boot.S ? In other words,
 what could go wrong if it were omitted in kern/mpentry.S ?
Hint: recall the differences between the link address and the load address 
that we have discussed in Lab 1.

boot.S与mpentry.S的区别是boot.S打开了A20总线。当mentry.S执行的时候，它的地址不是出于绝对的
地址，而是整个代码段都被加载到MPENTRY_PADDR上，所以执行的时候要通过宏MPBOOTPHYS计算出相对的地址。

2. It seems that using the big kernel lock guarantees that only one CPU can run 
the kernel code at a time. Why do we still need separate kernel stacks for each 
CPU? Describe a scenario in which using a shared kernel stack will go wrong, even 
with the protection of the big kernel lock.

因为每当cpu中断的时候都没有取锁，只有在处理中断的时候：trap()当中才取相应的锁，因此可能多个CPU都产生
中断，那同一个处理中断的栈的内容就会被损坏。

3. In your implementation of env_run() you should have called lcr3() . Before and 
after the call to lcr3() , your code makes references (at least it should) to the 
variable e , the argument to env_run . Upon loading the %cr3 register, the addressing 
context used by the MMU is instantly changed. But a virtual address (namely e ) has 
meaning relative to a given address context--the address context speciﬁes the physical 
address to which the virtual address maps. Why can the pointer e be dereferenced both 
before and after the addressing switch?

因为e的地址处于内核段。所有的env都有映射。