Answers of Lab4
1. Compare kern/mpentry.Sside by side with boot/boot.S . Bearing in mind 
that kern/mpentry.S is compiled and linked to run above KERNBASE just 
like everything else in the kernel, what is the purpose of macro MPBOOTPHYS ? 
Why is it necessary in kern/mpentry.S but not in boot/boot.S ? In other words,
 what could go wrong if it were omitted in kern/mpentry.S ?
Hint: recall the differences between the link address and the load address 
that we have discussed in Lab 1.

boot.S与mpentry.S的区别是boot.S打开了A20总线。当mentry.S执行的时候，它的地址不是出于绝对的
地址，而是整个代码段都被加载到MPENTRY_PADDR上，所以执行的时候要通过宏MPBOOTPHYS计算出相对的地址。

2. It seems that using the big kernel lock guarantees that only one CPU can run 
the kernel code at a time. Why do we still need separate kernel stacks for each 
CPU? Describe a scenario in which using a shared kernel stack will go wrong, even 
with the protection of the big kernel lock.

因为每当cpu中断的时候都没有取锁，只有在处理中断的时候：trap()当中才取相应的锁，因此可能多个CPU都产生
中断，那同一个处理中断的栈的内容就会被损坏。

3. In your implementation of env_run() you should have called lcr3() . Before and 
after the call to lcr3() , your code makes references (at least it should) to the 
variable e , the argument to env_run . Upon loading the %cr3 register, the addressing 
context used by the MMU is instantly changed. But a virtual address (namely e ) has 
meaning relative to a given address context--the address context speciﬁes the physical 
address to which the virtual address maps. Why can the pointer e be dereferenced both 
before and after the addressing switch?

因为e的地址处于内核段。所有的env都有映射。

Challenge 

此次lab的challenge部分实现了sfork的功能。由于lib/fork.c当中的实现很简单，根据thisenv当中的stack_bottom
与heap_top两个变量，为子进程拷贝heap_top之下的所有映射新建heap_top之上的物理页映射，然后将相应的内容进行拷贝。
lib/ipc.c中的ipc_recv()，注意到thisenv变量的地址处于堆上的部分，而堆上的变量是共享的，若按照原本的程序执行
(thisenv会一直指向子程序的环境变量)。所以应该改变lib/ipc.c当中的thisenv变成一个const volatile变量，每当将要
使用thisenv变量的时候，都自动获取相应的正确值：

env = &envs[ENVX(sys_getenvid())];
这样就可保证pingpongs当中不会产生所进程都处于NOT_RUNNABLE的状态。